from collections import OrderedDict, namedtuple
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type, Union

from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.aggregates import Aggregate
from django.db.models.base import Model
from django.db.models.expressions import Col, Combinable
from django.db.models.fields import Field
from django.db.models.fields.files import ImageField
from django.db.models.fields.mixins import FieldCacheMixin
from django.db.models.fields.related_lookups import MultiColSource
from django.db.models.fields.reverse_related import ForeignObjectRel
from django.db.models.lookups import BuiltinLookup
from django.db.models.options import Options
from django.db.models.query_utils import PathInfo, Q
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.datastructures import BaseTable, Join
from django.db.models.sql.subqueries import UpdateQuery
from django.db.models.sql.where import WhereNode

JoinInfo = namedtuple(
    "JoinInfo",
    ["final_field", "targets", "opts", "joins", "path", "transform_function"],
)

class RawQuery:
    params: Any = ...
    sql: Any = ...
    using: Any = ...
    cursor: Any = ...
    extra_select: Any = ...
    annotation_select: Any = ...
    def __init__(
        self, sql: Any, using: Any, params: Optional[Any] = ...
    ) -> None: ...
    def chain(self, using: Any): ...
    def clone(self, using: Any): ...
    def get_columns(self): ...
    def __iter__(self): ...
    @property
    def params_type(self): ...

class Query:
    base_table: str
    related_ids: None
    related_updates: Dict[Any, Any]
    values: Union[
        List[
            Tuple[
                django.db.models.fields.CharField,
                Type[django.db.models.base.Model],
                str,
            ]
        ],
        List[Tuple[django.db.models.fields.Field, None, Union[str, bool]]],
    ]
    alias_prefix: str = ...
    subq_aliases: frozenset = ...
    compiler: str = ...
    model: Optional[Type[django.db.models.base.Model]] = ...
    alias_refcount: Dict[str, int] = ...
    alias_map: collections.OrderedDict = ...
    external_aliases: Set[Any] = ...
    table_map: Dict[str, List[str]] = ...
    default_cols: bool = ...
    default_ordering: bool = ...
    standard_ordering: bool = ...
    used_aliases: Set[str] = ...
    filter_is_sticky: bool = ...
    subquery: bool = ...
    select: Union[Tuple, List[Any]] = ...
    where: django.db.models.sql.where.WhereNode = ...
    where_class: Type[django.db.models.sql.where.WhereNode] = ...
    group_by: Optional[bool] = ...
    order_by: Tuple = ...
    distinct: bool = ...
    distinct_fields: Tuple = ...
    select_for_update: bool = ...
    select_for_update_nowait: bool = ...
    select_for_update_skip_locked: bool = ...
    select_for_update_of: Tuple = ...
    select_related: Union[bool, Dict[str, Dict[Any, Any]]] = ...
    max_depth: int = ...
    values_select: Tuple = ...
    annotation_select_mask: Optional[Set[str]] = ...
    combinator: None = ...
    combinator_all: bool = ...
    combined_queries: Tuple = ...
    extra_select_mask: Optional[Set[str]] = ...
    extra_tables: Tuple = ...
    extra_order_by: Tuple = ...
    deferred_loading: Tuple[frozenset, bool] = ...
    explain_query: bool = ...
    explain_format: None = ...
    explain_options: Dict[Any, Any] = ...
    def __init__(
        self, model: Type[Model], where: Type[WhereNode] = ...
    ) -> None: ...
    @property
    def extra(self) -> OrderedDict: ...
    @property
    def annotations(self) -> OrderedDict: ...
    @property
    def has_select_fields(self): ...
    def base_table(self) -> str: ...
    def sql_with_params(self) -> Tuple[str, Tuple[int, int, int, int]]: ...
    def __deepcopy__(self, memo: Any): ...
    def get_compiler(
        self, using: str = ..., connection: None = ...
    ) -> SQLCompiler: ...
    def get_meta(self) -> Options: ...
    def clone(self) -> Query: ...
    def chain(self, klass: Optional[Type[UpdateQuery]] = ...) -> Query: ...
    def relabeled_clone(self, change_map: Any): ...
    def rewrite_cols(self, annotation: Any, col_cnt: Any): ...
    def get_aggregation(
        self, using: str, added_aggregate_names: Dict[str, Aggregate]
    ) -> Dict[str, datetime]: ...
    def get_count(self, using: Any): ...
    def has_filters(self): ...
    def has_results(self, using: str) -> bool: ...
    def explain(
        self, using: Any, format: Optional[Any] = ..., **options: Any
    ): ...
    def combine(self, rhs: Any, connector: Any) -> None: ...
    def deferred_to_data(
        self, target: Dict[Any, Any], callback: Callable
    ) -> None: ...
    def table_alias(
        self, table_name: str, create: bool = ..., filtered_relation: None = ...
    ) -> Tuple[str, bool]: ...
    def ref_alias(self, alias: str) -> None: ...
    def unref_alias(self, alias: str, amount: int = ...) -> None: ...
    def promote_joins(self, aliases: Set[Any]) -> None: ...
    def demote_joins(self, aliases: Set[str]) -> None: ...
    def reset_refcounts(self, to_counts: Dict[str, int]) -> None: ...
    def change_aliases(self, change_map: Any) -> None: ...
    def bump_prefix(self, outer_query: Any): ...
    def get_initial_alias(self) -> str: ...
    def count_active_tables(self) -> int: ...
    def join(
        self,
        join: Union[BaseTable, Join],
        reuse: Optional[Set[str]] = ...,
        reuse_with_filtered_relation: bool = ...,
    ) -> str: ...
    def join_parent_model(
        self,
        opts: Options,
        model: Optional[Type[Model]],
        alias: str,
        seen: Dict[Optional[Type[Model]], str],
    ) -> str: ...
    def add_annotation(
        self, annotation: Combinable, alias: str, is_summary: bool = ...
    ) -> None: ...
    def resolve_expression(self, query: Any, *args: Any, **kwargs: Any): ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, Union[Tuple[str, str], Tuple[str, int]]]: ...
    def resolve_lookup_value(
        self, value: Any, can_reuse: Set[str], allow_joins: bool
    ) -> Any: ...
    def solve_lookup_type(
        self, lookup: str
    ) -> Union[
        Tuple[List[str], List[str], bool], Tuple[List[str], Tuple, Col]
    ]: ...
    def check_query_object_type(
        self, value: Union[Model, int], opts: Options, field: FieldCacheMixin
    ) -> None: ...
    def check_related_objects(
        self,
        field: Union[Field, reverse_related.ForeignObjectRel],
        value: Any,
        opts: Options,
    ) -> None: ...
    def build_lookup(
        self, lookups: List[str], lhs: Union[Col, MultiColSource], rhs: Any
    ) -> BuiltinLookup: ...
    def try_transform(self, lhs: Col, name: str) -> Any: ...
    def build_filter(
        self,
        filter_expr: Tuple[str, Any],
        branch_negated: bool = ...,
        current_negated: bool = ...,
        can_reuse: Set[str] = ...,
        allow_joins: bool = ...,
        split_subq: bool = ...,
        reuse_with_filtered_relation: bool = ...,
    ) -> Tuple[WhereNode, Union[Tuple, Set[str], List[Any]]]: ...
    def add_filter(
        self,
        filter_clause: Tuple[str, Optional[Union[Tuple[str, str], str, Model]]],
    ) -> None: ...
    def add_q(self, q_object: Q) -> None: ...
    def build_filtered_relation_q(
        self,
        q_object: Any,
        reuse: Any,
        branch_negated: bool = ...,
        current_negated: bool = ...,
    ): ...
    def add_filtered_relation(
        self, filtered_relation: Any, alias: Any
    ) -> None: ...
    def names_to_path(
        self,
        names: List[str],
        opts: Options,
        allow_many: bool = ...,
        fail_on_missing: bool = ...,
    ) -> Union[
        Tuple[
            List[PathInfo],
            Field,
            Tuple[Field],
            Union[List[str], List[Any]],
            Union[List[str], List[Any]],
        ],
        Tuple[
            List[PathInfo],
            Tuple[Field],
            List[str],
            Union[List[str], List[Any]],
            Union[List[str], List[Any]],
        ],
    ]: ...
    def setup_joins(
        self,
        names: List[str],
        opts: Options,
        alias: str,
        can_reuse: Optional[Set[str]] = ...,
        allow_many: bool = ...,
        reuse_with_filtered_relation: bool = ...,
    ) -> JoinInfo: ...
    def trim_joins(
        self, targets: Tuple[Field], joins: List[str], path: List[PathInfo]
    ) -> Tuple[Tuple[Field], str, List[str]]: ...
    def resolve_ref(
        self,
        name: str,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
    ) -> Col: ...
    def split_exclude(
        self,
        filter_expr: Tuple[str, Optional[Union[Tuple[str, str], str, Model]]],
        can_reuse: Set[str],
        names_with_path: List[Tuple[str, List[PathInfo]]],
    ) -> Tuple[WhereNode, Tuple]: ...
    def set_empty(self) -> None: ...
    def is_empty(self): ...
    high_mark: Optional[int] = ...
    low_mark: int = ...
    def set_limits(self, low: None = ..., high: int = ...) -> None: ...
    def clear_limits(self) -> None: ...
    def has_limit_one(self): ...
    def can_filter(self) -> bool: ...
    def clear_select_clause(self) -> None: ...
    def clear_select_fields(self) -> None: ...
    def set_select(self, cols: List[Col]) -> None: ...
    def add_distinct_fields(self, *field_names: Any) -> None: ...
    def add_fields(
        self, field_names: List[str], allow_m2m: bool = ...
    ) -> None: ...
    def add_ordering(self, *ordering: Any) -> None: ...
    def clear_ordering(self, force_empty: bool) -> None: ...
    def set_group_by(self) -> None: ...
    def add_select_related(self, fields: Tuple[str, str]) -> None: ...
    def add_extra(
        self,
        select: Optional[Union[OrderedDict, Dict[str, str], Dict[str, int]]],
        select_params: Optional[Union[List[int], Tuple[int, int]]],
        where: None,
        params: None,
        tables: None,
        order_by: Optional[List[str]],
    ) -> None: ...
    def clear_deferred_loading(self) -> None: ...
    def add_deferred_loading(self, field_names: Any) -> None: ...
    def add_immediate_loading(self, field_names: Any) -> None: ...
    def get_loaded_field_names(self): ...
    def get_loaded_field_names_cb(
        self, target: Dict[Any, Any], model: Type[Model], fields: Field
    ) -> None: ...
    def set_annotation_mask(self, names: Union[Tuple, List[str]]) -> None: ...
    def append_annotation_mask(self, names: Any) -> None: ...
    def set_extra_mask(self, names: Union[Tuple, List[str]]) -> None: ...
    def set_values(self, fields: Union[List[str], Tuple[str]]) -> None: ...
    @property
    def annotation_select(self) -> Dict[Any, Any]: ...
    @property
    def extra_select(self) -> Union[OrderedDict, Dict[Any, Any]]: ...
    def trim_start(self, names_with_path: Any): ...
    def is_nullable(self, field: Field) -> bool: ...

class JoinPromoter:
    connector: Any = ...
    negated: Any = ...
    effective_connector: Any = ...
    num_children: Any = ...
    votes: Any = ...
    def __init__(
        self, connector: str, num_children: int, negated: bool
    ) -> None: ...
    def add_votes(self, votes: Union[Tuple, Set[str], List[Any]]) -> None: ...
    def update_join_types(self, query: Query) -> Set[str]: ...
