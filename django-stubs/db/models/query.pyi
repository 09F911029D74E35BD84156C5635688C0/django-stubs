# Stubs for django.db.models.query (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

from django.db.models.base import Model
from django.db.models.sql.query import Query
from typing import Any, Dict, Iterator, Optional, Tuple, Type, Union
REPR_OUTPUT_SIZE: int
EmptyResultSet: Any

class BaseIterable:
    queryset: Any = ...
    chunked_fetch: Any = ...
    chunk_size: Any = ...
    def __init__(self, queryset: QuerySet, chunked_fetch: bool = ..., chunk_size: int = ...) -> None: ...

class ModelIterable(BaseIterable):
    def __iter__(self) -> Iterator[Model]: ...

class ValuesIterable(BaseIterable):
    def __iter__(self) -> None: ...

class ValuesListIterable(BaseIterable):
    def __iter__(self): ...

class NamedValuesListIterable(ValuesListIterable):
    @staticmethod
    def create_namedtuple_class(*names: Any): ...
    def __iter__(self) -> None: ...

class FlatValuesListIterable(BaseIterable):
    def __iter__(self) -> Iterator[Any]: ...

class QuerySet:
    model: Any = ...
    _db: Any = ...
    _hints: Any = ...
    query: Any = ...
    _result_cache: Any = ...
    _sticky_filter: bool = ...
    _for_write: bool = ...
    _prefetch_related_lookups: Any = ...
    _prefetch_done: bool = ...
    _known_related_objects: Any = ...
    _iterable_class: Any = ...
    _fields: Any = ...
    def __init__(self, model: Type[Model] = ..., query: Optional[Query] = ..., using: Optional[str] = ..., hints: Dict[str, Model] = ...) -> None: ...
    def as_manager(cls): ...
    as_manager: Any = ...
    def __deepcopy__(self, memo: Any): ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: Any) -> None: ...
    def __repr__(self): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, k: Union[slice, int]) -> Any: ...
    def __and__(self, other: QuerySet) -> QuerySet: ...
    def __or__(self, other: Any): ...
    def _iterator(self, use_chunked_fetch: Any, chunk_size: Any) -> None: ...
    def iterator(self, chunk_size: int = ...): ...
    def aggregate(self, *args: Any, **kwargs: Any): ...
    def count(self): ...
    def get(self, *args: Any, **kwargs: Any): ...
    def create(self, **kwargs: Any): ...
    def _populate_pk_values(self, objs: Any) -> None: ...
    def bulk_create(self, objs: Any, batch_size: Optional[Any] = ...): ...
    def get_or_create(self, defaults: Optional[Any] = ..., **kwargs: Any): ...
    def update_or_create(self, defaults: Optional[Any] = ..., **kwargs: Any): ...
    def _create_object_from_params(self, lookup: Any, params: Any): ...
    def _extract_model_params(self, defaults: Any, **kwargs: Any): ...
    def _earliest_or_latest(self, *fields: Any, field_name: Optional[Any] = ...): ...
    def earliest(self, *fields: Any, field_name: Optional[Any] = ...): ...
    def latest(self, *fields: Any, field_name: Optional[Any] = ...): ...
    def first(self): ...
    def last(self): ...
    def in_bulk(self, id_list: Optional[Any] = ..., *, field_name: str = ...): ...
    def delete(self): ...
    def _raw_delete(self, using: Any): ...
    def update(self, **kwargs: Any): ...
    def _update(self, values: Any): ...
    def exists(self): ...
    def _prefetch_related_objects(self) -> None: ...
    def explain(self, *, format: Optional[Any] = ..., **options: Any): ...
    def raw(self, raw_query: Any, params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ...): ...
    def _values(self, *fields: Any, **expressions: Any): ...
    def values(self, *fields: Any, **expressions: Any): ...
    def values_list(self, *fields: Any, flat: bool = ..., named: bool = ...): ...
    def dates(self, field_name: Any, kind: Any, order: str = ...): ...
    def datetimes(self, field_name: Any, kind: Any, order: str = ..., tzinfo: Optional[Any] = ...): ...
    def none(self): ...
    def all(self): ...
    def filter(self, *args: Any, **kwargs: Any): ...
    def exclude(self, *args: Any, **kwargs: Any): ...
    def _filter_or_exclude(self, negate: Any, *args: Any, **kwargs: Any): ...
    def complex_filter(self, filter_obj: Any): ...
    def _combinator_query(self, combinator: Any, *other_qs: Any, all: bool = ...): ...
    def union(self, *other_qs: Any, all: bool = ...): ...
    def intersection(self, *other_qs: Any): ...
    def difference(self, *other_qs: Any): ...
    def select_for_update(self, nowait: bool = ..., skip_locked: bool = ..., of: Any = ...): ...
    def select_related(self, *fields: Any): ...
    def prefetch_related(self, *lookups: Any): ...
    def annotate(self, *args: Any, **kwargs: Any): ...
    def order_by(self, *field_names: Any): ...
    def distinct(self, *field_names: Any): ...
    def extra(self, select: Optional[Any] = ..., where: Optional[Any] = ..., params: Optional[Any] = ..., tables: Optional[Any] = ..., order_by: Optional[Any] = ..., select_params: Optional[Any] = ...): ...
    def reverse(self): ...
    def defer(self, *fields: Any): ...
    def only(self, *fields: Any): ...
    def using(self, alias: Any): ...
    @property
    def ordered(self): ...
    @property
    def db(self): ...
    def _insert(self, objs: Any, fields: Any, return_id: bool = ..., raw: bool = ..., using: Optional[Any] = ...): ...
    def _batched_insert(self, objs: Any, fields: Any, batch_size: Any): ...
    def _chain(self, **kwargs: Any): ...
    def _clone(self): ...
    def _fetch_all(self) -> None: ...
    def _next_is_sticky(self): ...
    def _merge_sanity_check(self, other: Any) -> None: ...
    def _merge_known_related_objects(self, other: Any) -> None: ...
    def resolve_expression(self, *args: Any, **kwargs: Any): ...
    def _add_hints(self, **hints: Any) -> None: ...
    def _has_filters(self): ...
    @staticmethod
    def _validate_values_are_expressions(values: Any, method_name: Any) -> None: ...

class InstanceCheckMeta(type):
    def __instancecheck__(self, instance: Union[str, QuerySet]) -> bool: ...

class EmptyQuerySet:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class RawQuerySet:
    raw_query: Any = ...
    model: Any = ...
    _db: Any = ...
    _hints: Any = ...
    query: Any = ...
    params: Any = ...
    translations: Any = ...
    _result_cache: Any = ...
    _prefetch_related_lookups: Any = ...
    _prefetch_done: bool = ...
    def __init__(self, raw_query: Any, model: Optional[Any] = ..., query: Optional[Any] = ..., params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ..., hints: Optional[Any] = ...) -> None: ...
    def resolve_model_init_order(self): ...
    def prefetch_related(self, *lookups: Any): ...
    def _prefetch_related_objects(self) -> None: ...
    def _clone(self): ...
    def _fetch_all(self) -> None: ...
    def __len__(self): ...
    def __bool__(self): ...
    def __iter__(self): ...
    def iterator(self) -> None: ...
    def __repr__(self): ...
    def __getitem__(self, k: Any): ...
    @property
    def db(self): ...
    def using(self, alias: Any): ...
    def columns(self): ...
    def model_fields(self): ...

class Prefetch:
    prefetch_through: Any = ...
    prefetch_to: Any = ...
    queryset: Any = ...
    to_attr: Any = ...
    def __init__(self, lookup: str, queryset: Optional[QuerySet] = ..., to_attr: Optional[str] = ...) -> None: ...
    def __getstate__(self) -> Dict[str, Optional[Union[str, QuerySet]]]: ...
    def add_prefix(self, prefix: str) -> None: ...
    def get_current_prefetch_to(self, level: int) -> str: ...
    def get_current_to_attr(self, level: int) -> Union[Tuple[str, None], Tuple[str, bool]]: ...
    def get_current_queryset(self, level: int) -> Optional[QuerySet]: ...
    def __eq__(self, other: None) -> bool: ...
    def __hash__(self) -> int: ...

def normalize_prefetch_lookups(lookups: Any, prefix: Optional[Any] = ...): ...
def prefetch_related_objects(model_instances: Any, *related_lookups: Any): ...
def get_prefetcher(instance: Any, through_attr: Any, to_attr: Any): ...
def prefetch_one_level(instances: Any, prefetcher: Any, lookup: Any, level: Any): ...

class RelatedPopulator:
    db: Any = ...
    cols_start: Any = ...
    cols_end: Any = ...
    init_list: Any = ...
    reorder_for_init: Any = ...
    model_cls: Any = ...
    pk_idx: Any = ...
    related_populators: Any = ...
    local_setter: Any = ...
    remote_setter: Any = ...
    def __init__(self, klass_info: Any, select: Any, db: Any) -> None: ...
    def populate(self, row: Any, from_obj: Any) -> None: ...

def get_related_populators(klass_info: Any, select: Any, db: Any): ...
