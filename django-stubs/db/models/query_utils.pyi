# Stubs for django.db.models.query_utils (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple
from django.utils import tree
from typing import Any, Optional

from collections import OrderedDict
from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.base import Model
from django.db.models.expressions import F
from django.db.models.fields import DateTimeCheckMixin, Field
from django.db.models.fields.related import ForeignKey
from django.db.models.fields.reverse_related import ManyToOneRel
from django.db.models.lookups import Lookup, Transform
from django.db.models.options import Options
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.query import Query
from django.db.models.sql.where import WhereNode
from typing import Any, Dict, Iterator, List, Optional, Set, Tuple, Type, Union

PathInfo = namedtuple(
    "PathInfo", "from_opts to_opts target_fields join_field m2m direct filtered_relation"
)

class InvalidQuery(Exception): ...

def subclasses(
    cls: Type[Union[Field, Transform]]
) -> Iterator[Type[Union[Field, Transform]]]: ...

class QueryWrapper:
    contains_aggregate: bool = ...
    data: Any = ...
    def __init__(self, sql: str, params: List[Any]) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler = ..., connection: DatabaseWrapper = ...
    ) -> Tuple[str, List[Any]]: ...

class Q(tree.Node):
    AND: str = ...
    OR: str = ...
    default: Any = ...
    conditional: bool = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def _combine(self, other: Q, conn: str) -> Q: ...
    def __or__(self, other: Q) -> Q: ...
    def __and__(self, other: Q) -> Q: ...
    def __invert__(self) -> Q: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> WhereNode: ...
    def deconstruct(
        self
    ) -> Union[
        Tuple[str, Tuple[Tuple[str, F], Tuple[str, F]], Dict[Any, Any]],
        Tuple[str, Tuple, Dict[str, F]],
        Tuple[str, Tuple[Q], Dict[Any, Any]],
    ]: ...

class DeferredAttribute:
    field_name: Any = ...
    def __init__(self, field_name: str) -> None: ...
    def __get__(
        self, instance: Optional[Model], cls: Type[Model] = ...
    ) -> Optional[Union[str, int, DeferredAttribute]]: ...
    def _check_parent_chain(self, instance: Model, name: str) -> None: ...

class RegisterLookupMixin:
    @classmethod
    def _get_lookup(cls, lookup_name: str) -> Any: ...
    @classmethod
    def get_lookups(cls) -> Dict[str, Type[Union[Lookup, Transform]]]: ...
    def get_lookup(self, lookup_name: str) -> Any: ...
    def get_transform(self, lookup_name: str) -> object: ...
    @staticmethod
    def merge_dicts(dicts: Any) -> Dict[str, Type[Union[Lookup, Transform]]]: ...
    @classmethod
    def _clear_cached_lookups(cls) -> None: ...
    @classmethod
    def register_lookup(
        cls, lookup: Type[Union[Lookup, Transform]], lookup_name: Optional[str] = ...
    ) -> Type[Union[Lookup, Transform]]: ...
    @classmethod
    def _unregister_lookup(
        cls, lookup: Type[Union[Lookup, Transform]], lookup_name: Optional[str] = ...
    ) -> None: ...

def select_related_descend(
    field: Union[Field, DateTimeCheckMixin],
    restricted: bool,
    requested: Any,
    load_fields: Optional[Set[str]],
    reverse: bool = ...,
) -> bool: ...
def refs_expression(lookup_parts: List[str], annotations: OrderedDict) -> Any: ...
def check_rel_lookup_compatibility(
    model: Type[Model], target_opts: Options, field: Union[ManyToOneRel, ForeignKey]
) -> bool: ...

class FilteredRelation:
    relation_name: Any = ...
    alias: Any = ...
    condition: Any = ...
    path: Any = ...
    def __init__(self, relation_name: str, *, condition: Any = ...) -> None: ...
    def __eq__(self, other: FilteredRelation) -> bool: ...
    def clone(self) -> FilteredRelation: ...
    def resolve_expression(self, *args: Any, **kwargs: Any) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[
        Tuple[str, List[int]],
        Tuple[str, List[str]],
        Tuple[str, List[Any]],
        Tuple[str, List[Union[int, str]]],
    ]: ...
