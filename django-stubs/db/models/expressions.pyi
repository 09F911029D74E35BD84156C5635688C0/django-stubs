from collections import OrderedDict
from datetime import (
    datetime,
    timedelta,
)
from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.aggregates import (
    Aggregate,
    Count,
)
from django.db.models.fields import (
    DateTimeCheckMixin,
    Field,
)
from django.db.models.fields.related import ForeignKey
from django.db.models.fields.reverse_related import (
    ForeignObjectRel,
    OneToOneRel,
)
from django.db.models.functions.datetime import Trunc
from django.db.models.functions.text import BytesToCharFieldConversionMixin
from django.db.models.query_utils import Q
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.query import Query
from django.db.models.sql.where import WhereNode
from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Set,
    Tuple,
    Union,
)


class BaseExpression:
    def __eq__(self, other: Expression) -> bool: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __hash__(self) -> int: ...
    def __init__(
        self,
        output_field: Optional[Union[str, ForeignObjectRel, Field]] = ...
    ) -> None: ...
    @staticmethod
    def _convert_value_noop(
        value: str,
        expression: BytesToCharFieldConversionMixin,
        connection: DatabaseWrapper
    ) -> str: ...
    @cached_property
    def _output_field_or_none(
        self
    ) -> Optional[Union[Field, DateTimeCheckMixin]]: ...
    def _parse_expressions(self, *expressions) -> Any: ...
    def _prepare(
        self,
        field: Union[Field, DateTimeCheckMixin, reverse_related.OneToOneRel]
    ) -> Expression: ...
    def _resolve_output_field(
        self
    ) -> Optional[Union[Field, DateTimeCheckMixin]]: ...
    def asc(self, **kwargs) -> OrderBy: ...
    @cached_property
    def contains_aggregate(self) -> bool: ...
    @cached_property
    def contains_column_references(self) -> bool: ...
    @cached_property
    def contains_over_clause(self) -> bool: ...
    @cached_property
    def convert_value(self) -> Callable: ...
    def copy(
        self
    ) -> Union[OrderBy, Expression, SQLiteNumericMixin]: ...
    def desc(self, **kwargs) -> OrderBy: ...
    @property
    def field(
        self
    ) -> Union[ForeignObjectRel, Field, DateTimeCheckMixin]: ...
    def flatten(self) -> Iterator[Union[Value, Func]]: ...
    def get_db_converters(self, connection: DatabaseWrapper) -> List[Callable]: ...
    def get_group_by_cols(
        self
    ) -> Union[List[CombinedExpression], List[Trunc], List[Col]]: ...
    def get_lookup(self, lookup: str) -> object: ...
    def get_source_expressions(self) -> List[Any]: ...
    def get_source_fields(self) -> Any: ...
    def get_transform(self, name: str) -> Any: ...
    @cached_property
    def output_field(self) -> Union[Field, DateTimeCheckMixin]: ...
    def relabeled_clone(
        self,
        change_map: Union[OrderedDict, Dict[Union[str, None], str]]
    ) -> Expression: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> Union[OrderBy, Expression]: ...
    def set_source_expressions(self, exprs: List[Any]) -> None: ...


class Case:
    def __init__(self, *cases, default = ..., output_field = ..., **extra) -> None: ...
    def __repr__(self) -> str: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        case_joiner: None = ...,
        **extra_context
    ) -> Any: ...
    def copy(self) -> Case: ...
    def get_source_expressions(self) -> List[Expression]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> Case: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...


class Col:
    def __init__(
        self,
        alias: str,
        target: Union[Field, DateTimeCheckMixin],
        output_field: Optional[Union[reverse_related.ForeignObjectRel, Field]] = ...
    ) -> None: ...
    def __repr__(self) -> str: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...
    def get_db_converters(self, connection: DatabaseWrapper) -> List[Callable]: ...
    def get_group_by_cols(self) -> List[Col]: ...
    def relabeled_clone(
        self,
        relabels: Union[OrderedDict, Dict[str, str]]
    ) -> Col: ...


class Combinable:
    def __add__(
        self,
        other: Union[float, timedelta, F, Aggregate]
    ) -> CombinedExpression: ...
    def __mod__(self, other: int) -> CombinedExpression: ...
    def __mul__(
        self,
        other: Union[int, F, Value]
    ) -> CombinedExpression: ...
    def __radd__(
        self,
        other: Optional[Union[float, timedelta]]
    ) -> CombinedExpression: ...
    def __rand__(self, other: object): ...
    def __rmul__(self, other: float) -> CombinedExpression: ...
    def __ror__(self, other: object): ...
    def __rsub__(self, other: float) -> CombinedExpression: ...
    def __rtruediv__(self, other: int) -> CombinedExpression: ...
    def __sub__(
        self,
        other: Union[float, timedelta, F]
    ) -> CombinedExpression: ...
    def __truediv__(
        self,
        other: Union[int, Count]
    ) -> CombinedExpression: ...
    def _combine(self, other: Any, connector: str, reversed: bool) -> CombinedExpression: ...
    def bitleftshift(self, other: int) -> CombinedExpression: ...


class CombinedExpression:
    def __init__(
        self,
        lhs: Combinable,
        connector: str,
        rhs: Union[F, Expression],
        output_field: None = ...
    ) -> None: ...
    def __str__(self) -> str: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[int]], Tuple[str, List[float]], Tuple[str, List[Any]], Tuple[str, List[datetime]]]: ...
    def get_source_expressions(self) -> Any: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> CombinedExpression: ...
    def set_source_expressions(self, exprs: Any) -> None: ...


class DurationExpression:
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...
    def compile(
        self,
        side: Expression,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[datetime]], Tuple[str, List[Any]]]: ...


class DurationValue:
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...


class Exists:
    def __init__(self, *args, negated = ..., **kwargs) -> None: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        **extra_context
    ) -> Union[Tuple[str, Tuple], Tuple[str, Tuple[int]]]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        *args,
        **kwargs
    ) -> Exists: ...


class ExpressionList:
    def __init__(self, *expressions, **extra): ...


class ExpressionWrapper:
    def __init__(
        self,
        expression: Union[Q, CombinedExpression],
        output_field: Field
    ) -> None: ...
    def __repr__(self) -> str: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[int]], Tuple[str, List[Any]]]: ...
    def get_source_expressions(
        self
    ) -> Union[List[CombinedExpression], List[Q], List[WhereNode]]: ...
    def set_source_expressions(
        self,
        exprs: Union[List[CombinedExpression], List[WhereNode]]
    ) -> None: ...


class F:
    def __eq__(self, other: F) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self, name: Union[str, OuterRef]) -> None: ...
    def __repr__(self) -> str: ...
    def asc(self, **kwargs) -> OrderBy: ...
    def desc(self, **kwargs) -> OrderBy: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> Expression: ...


class Func:
    def __init__(self, *expressions, output_field = ..., **extra) -> None: ...
    def __repr__(self) -> str: ...
    def _get_repr_options(self) -> Dict[Any, Any]: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        function: Optional[str] = ...,
        template: Optional[str] = ...,
        arg_joiner: Optional[str] = ...,
        **extra_context
    ) -> Any: ...
    def copy(self) -> Func: ...
    def get_source_expressions(self) -> Any: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> Func: ...
    def set_source_expressions(self, exprs: Any) -> None: ...


class OrderBy:
    def __init__(
        self,
        expression: Union[F, Expression],
        descending: bool = ...,
        nulls_first: bool = ...,
        nulls_last: bool = ...
    ) -> None: ...
    def __repr__(self) -> str: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: Optional[str] = ...,
        **extra_context
    ) -> Union[Tuple[str, List[int]], Tuple[str, Tuple], Tuple[str, List[Any]]]: ...
    def as_sqlite(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper
    ) -> Any: ...
    def get_source_expressions(self) -> Any: ...
    def reverse_ordering(self) -> OrderBy: ...
    def set_source_expressions(self, exprs: Any) -> None: ...


class OuterRef:
    def _prepare(
        self,
        output_field: ForeignKey = ...
    ) -> OuterRef: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...
    ) -> F: ...


class Random:
    def __repr__(self) -> str: ...


class RawSQL:
    def __init__(self, sql: str, params: List[int], output_field: None = ...) -> None: ...