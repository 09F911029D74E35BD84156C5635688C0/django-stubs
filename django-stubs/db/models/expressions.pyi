# Stubs for django.db.models.expressions (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

from collections import OrderedDict
from datetime import datetime, timedelta
from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.aggregates import Aggregate, Count
from django.db.models.fields import DateTimeCheckMixin, Field
from django.db.models.fields.related import ForeignKey
from django.db.models.fields.reverse_related import ForeignObjectRel, OneToOneRel
from django.db.models.functions.datetime import Trunc
from django.db.models.functions.text import BytesToCharFieldConversionMixin
from django.db.models.query_utils import Q
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.query import Query
from django.db.models.sql.where import WhereNode
from typing import Any, Callable, Dict, Iterator, List, Optional, Set, Tuple, Union

class SQLiteNumericMixin:
    def as_sqlite(self, compiler: Any, connection: Any, **extra_context: Any): ...

class Combinable:
    ADD: str = ...
    SUB: str = ...
    MUL: str = ...
    DIV: str = ...
    POW: str = ...
    MOD: str = ...
    BITAND: str = ...
    BITOR: str = ...
    BITLEFTSHIFT: str = ...
    BITRIGHTSHIFT: str = ...
    def _combine(
        self, other: Any, connector: str, reversed: bool
    ) -> CombinedExpression: ...
    def __neg__(self): ...
    def __add__(
        self, other: Union[float, timedelta, F, Aggregate]
    ) -> CombinedExpression: ...
    def __sub__(self, other: Union[float, timedelta, F]) -> CombinedExpression: ...
    def __mul__(self, other: Union[int, F, Value]) -> CombinedExpression: ...
    def __truediv__(self, other: Union[int, Count]) -> CombinedExpression: ...
    def __mod__(self, other: int) -> CombinedExpression: ...
    def __pow__(self, other: Any): ...
    def __and__(self, other: Any) -> None: ...
    def bitand(self, other: Any): ...
    def bitleftshift(self, other: int) -> CombinedExpression: ...
    def bitrightshift(self, other: Any): ...
    def __or__(self, other: Any) -> None: ...
    def bitor(self, other: Any): ...
    def __radd__(self, other: Optional[Union[float, timedelta]]) -> CombinedExpression: ...
    def __rsub__(self, other: float) -> CombinedExpression: ...
    def __rmul__(self, other: float) -> CombinedExpression: ...
    def __rtruediv__(self, other: int) -> CombinedExpression: ...
    def __rmod__(self, other: Any): ...
    def __rpow__(self, other: Any): ...
    def __rand__(self, other: object) -> None: ...
    def __ror__(self, other: object) -> None: ...

class BaseExpression:
    is_summary: bool = ...
    _output_field_resolved_to_none: bool = ...
    filterable: bool = ...
    window_compatible: bool = ...
    output_field: Any = ...
    def __init__(
        self, output_field: Optional[Union[str, ForeignObjectRel, Field]] = ...
    ) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def get_db_converters(self, connection: DatabaseWrapper) -> List[Callable]: ...
    def get_source_expressions(self) -> List[Any]: ...
    def set_source_expressions(self, exprs: List[Any]) -> None: ...
    def _parse_expressions(self, *expressions: Any) -> Any: ...
    def as_sql(self, compiler: Any, connection: Any) -> None: ...
    def contains_aggregate(self) -> bool: ...
    def contains_over_clause(self) -> bool: ...
    def contains_column_references(self) -> bool: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Union[OrderBy, Expression]: ...
    def _prepare(
        self, field: Union[Field, DateTimeCheckMixin, reverse_related.OneToOneRel]
    ) -> Expression: ...
    @property
    def field(self) -> Union[ForeignObjectRel, Field, DateTimeCheckMixin]: ...
    def output_field(self) -> Union[Field, DateTimeCheckMixin]: ...
    def _output_field_or_none(self) -> Optional[Union[Field, DateTimeCheckMixin]]: ...
    def _resolve_output_field(self) -> Optional[Union[Field, DateTimeCheckMixin]]: ...
    @staticmethod
    def _convert_value_noop(
        value: str, expression: BytesToCharFieldConversionMixin, connection: DatabaseWrapper
    ) -> str: ...
    def convert_value(self) -> Callable: ...
    def get_lookup(self, lookup: str) -> object: ...
    def get_transform(self, name: str) -> Any: ...
    def relabeled_clone(
        self, change_map: Union[OrderedDict, Dict[Union[str, None], str]]
    ) -> Expression: ...
    def copy(self) -> Union[OrderBy, Expression, SQLiteNumericMixin]: ...
    def get_group_by_cols(
        self
    ) -> Union[List[CombinedExpression], List[Trunc], List[Col]]: ...
    def get_source_fields(self) -> Any: ...
    def asc(self, **kwargs: Any) -> OrderBy: ...
    def desc(self, **kwargs: Any) -> OrderBy: ...
    def reverse_ordering(self): ...
    def flatten(self) -> Iterator[Union[Value, Func]]: ...
    def __eq__(self, other: Expression) -> bool: ...
    def __hash__(self) -> int: ...

class Expression(BaseExpression, Combinable): ...

class CombinedExpression(SQLiteNumericMixin, Expression):
    connector: Any = ...
    lhs: Any = ...
    rhs: Any = ...
    def __init__(
        self,
        lhs: Combinable,
        connector: str,
        rhs: Union[F, Expression],
        output_field: None = ...,
    ) -> None: ...
    def __repr__(self): ...
    def __str__(self) -> str: ...
    def get_source_expressions(self) -> Any: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[
        Tuple[str, List[int]],
        Tuple[str, List[float]],
        Tuple[str, List[Any]],
        Tuple[str, List[datetime]],
    ]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> CombinedExpression: ...

class DurationExpression(CombinedExpression):
    def compile(
        self, side: Expression, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[datetime]], Tuple[str, List[Any]]]: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...

class TemporalSubtraction(CombinedExpression):
    output_field: Any = ...
    def __init__(self, lhs: Any, rhs: Any) -> None: ...
    def as_sql(self, compiler: Any, connection: Any): ...

class F(Combinable):
    filterable: bool = ...
    name: Any = ...
    def __init__(self, name: Union[str, OuterRef]) -> None: ...
    def __repr__(self) -> str: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Expression: ...
    def asc(self, **kwargs: Any) -> OrderBy: ...
    def desc(self, **kwargs: Any) -> OrderBy: ...
    def __eq__(self, other: F) -> bool: ...
    def __hash__(self) -> int: ...

class ResolvedOuterRef(F):
    def as_sql(self, *args: Any, **kwargs: Any) -> None: ...
    def _prepare(self, output_field: Optional[Any] = ...): ...
    def relabeled_clone(self, relabels: Any): ...

class OuterRef(F):
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> F: ...
    def _prepare(self, output_field: ForeignKey = ...) -> OuterRef: ...

class Func(SQLiteNumericMixin, Expression):
    function: Any = ...
    template: str = ...
    arg_joiner: str = ...
    arity: Any = ...
    source_expressions: Any = ...
    extra: Any = ...
    def __init__(
        self, *expressions: Any, output_field: Optional[Any] = ..., **extra: Any
    ) -> None: ...
    def __repr__(self) -> str: ...
    def _get_repr_options(self) -> Dict[Any, Any]: ...
    def get_source_expressions(self) -> Any: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Func: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        function: Optional[str] = ...,
        template: Optional[str] = ...,
        arg_joiner: Optional[str] = ...,
        **extra_context: Any,
    ) -> Any: ...
    def copy(self) -> Func: ...

class Value(Expression):
    value: Any = ...
    def __init__(self, value: Any, output_field: Optional[Any] = ...) -> None: ...
    def __repr__(self): ...
    def as_sql(self, compiler: Any, connection: Any): ...
    def resolve_expression(
        self,
        query: Optional[Any] = ...,
        allow_joins: bool = ...,
        reuse: Optional[Any] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ): ...
    def get_group_by_cols(self): ...

class DurationValue(Value):
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...

class RawSQL(Expression):
    def __init__(self, sql: str, params: List[int], output_field: None = ...) -> None: ...
    def __repr__(self): ...
    def as_sql(self, compiler: Any, connection: Any): ...
    def get_group_by_cols(self): ...
    def __hash__(self): ...

class Star(Expression):
    def __repr__(self): ...
    def as_sql(self, compiler: Any, connection: Any): ...

class Random(Expression):
    output_field: Any = ...
    def __repr__(self) -> str: ...
    def as_sql(self, compiler: Any, connection: Any): ...

class Col(Expression):
    contains_column_references: bool = ...
    def __init__(
        self,
        alias: str,
        target: Union[Field, DateTimeCheckMixin],
        output_field: Optional[Union[reverse_related.ForeignObjectRel, Field]] = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...
    def relabeled_clone(self, relabels: Union[OrderedDict, Dict[str, str]]) -> Col: ...
    def get_group_by_cols(self) -> List[Col]: ...
    def get_db_converters(self, connection: DatabaseWrapper) -> List[Callable]: ...

class Ref(Expression):
    def __init__(self, refs: Any, source: Any) -> None: ...
    def __repr__(self): ...
    def get_source_expressions(self): ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def resolve_expression(
        self,
        query: Optional[Any] = ...,
        allow_joins: bool = ...,
        reuse: Optional[Any] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ): ...
    def relabeled_clone(self, relabels: Any): ...
    def as_sql(self, compiler: Any, connection: Any): ...
    def get_group_by_cols(self): ...

class ExpressionList(Func):
    template: str = ...
    def __init__(self, *expressions: Any, **extra: Any) -> None: ...
    def __str__(self): ...

class ExpressionWrapper(Expression):
    expression: Any = ...
    def __init__(
        self, expression: Union[Q, CombinedExpression], output_field: Field
    ) -> None: ...
    def set_source_expressions(
        self, exprs: Union[List[CombinedExpression], List[WhereNode]]
    ) -> None: ...
    def get_source_expressions(
        self
    ) -> Union[List[CombinedExpression], List[Q], List[WhereNode]]: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[int]], Tuple[str, List[Any]]]: ...
    def __repr__(self) -> str: ...

class When(Expression):
    template: str = ...
    condition: Any = ...
    result: Any = ...
    def __init__(
        self, condition: Optional[Any] = ..., then: Optional[Any] = ..., **lookups: Any
    ) -> None: ...
    def __str__(self): ...
    def __repr__(self): ...
    def get_source_expressions(self): ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def get_source_fields(self): ...
    def resolve_expression(
        self,
        query: Optional[Any] = ...,
        allow_joins: bool = ...,
        reuse: Optional[Any] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ): ...
    def as_sql(
        self,
        compiler: Any,
        connection: Any,
        template: Optional[Any] = ...,
        **extra_context: Any,
    ): ...
    def get_group_by_cols(self): ...

class Case(Expression):
    template: str = ...
    case_joiner: str = ...
    cases: Any = ...
    default: Any = ...
    extra: Any = ...
    def __init__(
        self,
        *cases: Any,
        default: Optional[Any] = ...,
        output_field: Optional[Any] = ...,
        **extra: Any,
    ) -> None: ...
    def __str__(self): ...
    def __repr__(self) -> str: ...
    def get_source_expressions(self) -> List[Expression]: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Case: ...
    def copy(self) -> Case: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        case_joiner: None = ...,
        **extra_context: Any,
    ) -> Any: ...

class Subquery(Expression):
    template: str = ...
    queryset: Any = ...
    extra: Any = ...
    def __init__(
        self, queryset: Any, output_field: Optional[Any] = ..., **extra: Any
    ) -> None: ...
    def _resolve_output_field(self): ...
    def copy(self): ...
    def resolve_expression(
        self,
        query: Optional[Any] = ...,
        allow_joins: bool = ...,
        reuse: Optional[Any] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ): ...
    def get_source_expressions(self): ...
    def relabeled_clone(self, change_map: Any): ...
    def as_sql(
        self,
        compiler: Any,
        connection: Any,
        template: Optional[Any] = ...,
        **extra_context: Any,
    ): ...
    def _prepare(self, output_field: Any): ...

class Exists(Subquery):
    template: str = ...
    output_field: Any = ...
    negated: Any = ...
    def __init__(self, *args: Any, negated: bool = ..., **kwargs: Any) -> None: ...
    def __invert__(self): ...
    queryset: Any = ...
    def resolve_expression(
        self, query: Query = ..., *args: Any, **kwargs: Any
    ) -> Exists: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        **extra_context: Any,
    ) -> Union[Tuple[str, Tuple], Tuple[str, Tuple[int]]]: ...
    def as_oracle(
        self,
        compiler: Any,
        connection: Any,
        template: Optional[Any] = ...,
        **extra_context: Any,
    ): ...

class OrderBy(BaseExpression):
    template: str = ...
    nulls_first: Any = ...
    nulls_last: Any = ...
    descending: Any = ...
    expression: Any = ...
    def __init__(
        self,
        expression: Union[F, Expression],
        descending: bool = ...,
        nulls_first: bool = ...,
        nulls_last: bool = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def get_source_expressions(self) -> Any: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: Optional[str] = ...,
        **extra_context: Any,
    ) -> Union[Tuple[str, List[int]], Tuple[str, Tuple], Tuple[str, List[Any]]]: ...
    def as_sqlite(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def as_mysql(self, compiler: Any, connection: Any): ...
    def get_group_by_cols(self): ...
    def reverse_ordering(self) -> OrderBy: ...
    def asc(self) -> None: ...
    def desc(self) -> None: ...

class Window(Expression):
    template: str = ...
    contains_aggregate: bool = ...
    contains_over_clause: bool = ...
    filterable: bool = ...
    partition_by: Any = ...
    order_by: Any = ...
    frame: Any = ...
    source_expression: Any = ...
    def __init__(
        self,
        expression: Any,
        partition_by: Optional[Any] = ...,
        order_by: Optional[Any] = ...,
        frame: Optional[Any] = ...,
        output_field: Optional[Any] = ...,
    ) -> None: ...
    def _resolve_output_field(self): ...
    def get_source_expressions(self): ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def as_sql(
        self,
        compiler: Any,
        connection: Any,
        function: Optional[Any] = ...,
        template: Optional[Any] = ...,
    ): ...
    def __str__(self): ...
    def __repr__(self): ...
    def get_group_by_cols(self): ...

class WindowFrame(Expression):
    template: str = ...
    start: Any = ...
    end: Any = ...
    def __init__(self, start: Optional[Any] = ..., end: Optional[Any] = ...) -> None: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def get_source_expressions(self): ...
    def as_sql(self, compiler: Any, connection: Any): ...
    def __repr__(self): ...
    def get_group_by_cols(self): ...
    def __str__(self): ...
    def window_frame_start_end(self, connection: Any, start: Any, end: Any) -> None: ...

class RowRange(WindowFrame):
    frame_type: str = ...
    def window_frame_start_end(self, connection: Any, start: Any, end: Any): ...

class ValueRange(WindowFrame):
    frame_type: str = ...
    def window_frame_start_end(self, connection: Any, start: Any, end: Any): ...
