from collections import OrderedDict
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from typing import (Any, Callable, Dict, Iterator, List, Optional, Set, Tuple,
                    Type, Union)
from uuid import UUID

from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.aggregates import Aggregate, Count, Sum
from django.db.models.fields import (AutoField, BinaryField, BooleanField,
                                     DateTimeField, DurationField, Field,
                                     IntegerField, TimeField, UUIDField)
from django.db.models.fields.mixins import FieldCacheMixin
from django.db.models.fields.reverse_related import ForeignObjectRel
from django.db.models.functions.window import DenseRank
from django.db.models.lookups import Lookup, Transform
from django.db.models.query import QuerySet
from django.db.models.query_utils import Q
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.query import Query
from django.db.models.sql.where import WhereNode
from django.utils.tree import Node


class SQLiteNumericMixin:
    def as_sqlite(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        **extra_context: Any
    ) -> Tuple[
        str,
        Union[List[Union[int, str]], List[date], List[Decimal], List[float]],
    ]: ...

class Combinable:
    ADD: str = ...
    SUB: str = ...
    MUL: str = ...
    DIV: str = ...
    POW: str = ...
    MOD: str = ...
    BITAND: str = ...
    BITOR: str = ...
    BITLEFTSHIFT: str = ...
    BITRIGHTSHIFT: str = ...
    def __neg__(self) -> CombinedExpression: ...
    def __add__(self, other: Any) -> CombinedExpression: ...
    def __sub__(
        self, other: Union[timedelta, Combinable, float]
    ) -> CombinedExpression: ...
    def __mul__(
        self, other: Union[timedelta, Combinable, float]
    ) -> CombinedExpression: ...
    def __truediv__(self, other: Union[Count, float]) -> CombinedExpression: ...
    def __mod__(self, other: int) -> CombinedExpression: ...
    def __pow__(self, other: float) -> CombinedExpression: ...
    def __and__(self, other: Combinable) -> Any: ...
    def bitand(self, other: int) -> CombinedExpression: ...
    def bitleftshift(self, other: int) -> CombinedExpression: ...
    def bitrightshift(self, other: int) -> CombinedExpression: ...
    def __or__(self, other: Combinable) -> Any: ...
    def bitor(self, other: int) -> CombinedExpression: ...
    def __radd__(
        self, other: Optional[Union[datetime, timedelta, float]]
    ) -> CombinedExpression: ...
    def __rsub__(self, other: float) -> CombinedExpression: ...
    def __rmul__(self, other: float) -> CombinedExpression: ...
    def __rtruediv__(self, other: float) -> CombinedExpression: ...
    def __rmod__(self, other: int) -> CombinedExpression: ...
    def __rpow__(self, other: float) -> CombinedExpression: ...
    def __rand__(self, other: Any) -> Any: ...
    def __ror__(self, other: Any) -> Any: ...

class BaseExpression:
    is_summary: bool = ...
    filterable: bool = ...
    window_compatible: bool = ...
    output_field: Any = ...
    def __init__(
        self,
        output_field: Optional[
            Union[Field, reverse_related.ForeignObjectRel, str]
        ] = ...,
    ) -> None: ...
    def get_db_converters(
        self, connection: DatabaseWrapper
    ) -> List[Callable]: ...
    def get_source_expressions(self) -> List[Any]: ...
    def set_source_expressions(self, exprs: List[Any]) -> None: ...
    def as_sql(self, compiler: Any, connection: Any) -> None: ...
    def contains_aggregate(self) -> bool: ...
    def contains_over_clause(self) -> bool: ...
    def contains_column_references(self) -> bool: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> BaseExpression: ...
    @property
    def field(self) -> Union[Field, ForeignObjectRel]: ...
    def output_field(self) -> Field: ...
    def convert_value(self) -> Callable: ...
    def get_lookup(self, lookup: str) -> Optional[Type[Lookup]]: ...
    def get_transform(self, name: str) -> Optional[Type[Transform]]: ...
    def relabeled_clone(
        self, change_map: Dict[Optional[str], str]
    ) -> Expression: ...
    def copy(self) -> BaseExpression: ...
    def get_group_by_cols(self) -> List[Expression]: ...
    def get_source_fields(self) -> List[Optional[Field]]: ...
    def asc(self, **kwargs: Any) -> OrderBy: ...
    def desc(self, **kwargs: Any) -> OrderBy: ...
    def reverse_ordering(self): ...
    def flatten(self) -> Iterator[Expression]: ...
    def __eq__(self, other: Combinable) -> bool: ...
    def __hash__(self) -> int: ...

class Expression(BaseExpression, Combinable): ...

class CombinedExpression(SQLiteNumericMixin, Expression):
    connector: Any = ...
    lhs: Any = ...
    rhs: Any = ...
    def __init__(
        self,
        lhs: Combinable,
        connector: str,
        rhs: Combinable,
        output_field: None = ...,
    ) -> None: ...
    def get_source_expressions(
        self
    ) -> Union[List[Combinable], List[SQLiteNumericMixin]]: ...
    def set_source_expressions(self, exprs: List[Combinable]) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[
        str, Union[List[datetime], List[float], List[int], List[str]]
    ]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> CombinedExpression: ...

class DurationExpression(CombinedExpression):
    def compile(
        self,
        side: Expression,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
    ) -> Tuple[str, Union[List[datetime], List[int]]]: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, Union[List[datetime], List[int]]]: ...

class TemporalSubtraction(CombinedExpression):
    output_field: Any = ...
    def __init__(self, lhs: Col, rhs: Expression) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[str]]: ...

class F(Combinable):
    filterable: bool = ...
    name: str = ...
    def __init__(self, name: Union[OuterRef, str]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Expression: ...
    def asc(self, **kwargs: Any) -> OrderBy: ...
    def desc(self, **kwargs: Any) -> OrderBy: ...
    def __eq__(self, other: Combinable) -> bool: ...
    def __hash__(self) -> int: ...

class ResolvedOuterRef(F):
    name: str
    def as_sql(self, *args: Any, **kwargs: Any) -> Any: ...
    def relabeled_clone(self, relabels: OrderedDict) -> ResolvedOuterRef: ...

class OuterRef(F):
    name: str
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> F: ...

class Func(SQLiteNumericMixin, Expression):
    function: Any = ...
    template: str = ...
    arg_joiner: str = ...
    arity: Any = ...
    source_expressions: Any = ...
    extra: Any = ...
    def __init__(
        self, *expressions: Any, output_field: Optional[Any] = ..., **extra: Any
    ) -> None: ...
    def get_source_expressions(self) -> List[Combinable]: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[Any]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Func: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        function: Optional[str] = ...,
        template: Optional[str] = ...,
        arg_joiner: Optional[str] = ...,
        **extra_context: Any
    ) -> Tuple[
        str,
        Union[List[Union[int, str]], List[date], List[Decimal], List[float]],
    ]: ...
    def copy(self) -> Func: ...

class Value(Expression):
    value: Any = ...
    def __init__(
        self, value: Any, output_field: Optional[Field] = ...
    ) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[
        str,
        Union[
            List[date],
            List[Decimal],
            List[float],
            List[int],
            List[memoryview],
            List[str],
        ],
    ]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Value: ...
    def get_group_by_cols(self) -> List[Any]: ...

class DurationValue(Value):
    output_field: django.db.models.fields.DurationField
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...

class RawSQL(Expression):
    output_field: django.db.models.fields.Field
    params: List[Any]
    sql: str
    def __init__(
        self,
        sql: str,
        params: Union[List[int], List[str], Tuple],
        output_field: None = ...,
    ) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, Union[List[int], List[str], Tuple]]: ...
    def get_group_by_cols(self) -> List[RawSQL]: ...
    def __hash__(self): ...

class Star(Expression):
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...

class Random(Expression):
    output_field: Any = ...
    def as_sql(self, compiler: Any, connection: Any): ...

class Col(Expression):
    output_field: django.db.models.fields.CharField
    contains_column_references: bool = ...
    def __init__(
        self,
        alias: str,
        target: Union[Field, str],
        output_field: Optional[
            Union[Field, reverse_related.ForeignObjectRel]
        ] = ...,
    ) -> None: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...
    def relabeled_clone(self, relabels: Dict[str, str]) -> Col: ...
    def get_group_by_cols(self) -> List[Col]: ...
    def get_db_converters(
        self, connection: DatabaseWrapper
    ) -> List[Callable]: ...

class Ref(Expression):
    def __init__(self, refs: str, source: Expression) -> None: ...
    def get_source_expressions(self) -> List[Expression]: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: None = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Ref: ...
    def relabeled_clone(self, relabels: Dict[Optional[str], str]) -> Ref: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...
    def get_group_by_cols(self): ...

class ExpressionList(Func):
    template: str = ...
    def __init__(self, *expressions: Any, **extra: Any) -> None: ...

class ExpressionWrapper(Expression):
    output_field: django.db.models.fields.BooleanField
    expression: Any = ...
    def __init__(
        self, expression: Union[CombinedExpression, Q], output_field: Field
    ) -> None: ...
    def set_source_expressions(
        self, exprs: Union[List[CombinedExpression], List[WhereNode]]
    ) -> None: ...
    def get_source_expressions(
        self
    ) -> Union[List[CombinedExpression], List[Node]]: ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, Union[List[int], List[str]]]: ...

class When(Expression):
    template: str = ...
    condition: Any = ...
    result: Any = ...
    def __init__(
        self, condition: Any = ..., then: Any = ..., **lookups: Any
    ) -> None: ...
    def get_source_expressions(self) -> List[Union[Expression, WhereNode]]: ...
    def set_source_expressions(
        self, exprs: List[Union[Expression, WhereNode]]
    ) -> None: ...
    def get_source_fields(self) -> Union[List[None], List[Field]]: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> When: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        **extra_context: Any
    ) -> Tuple[
        str,
        Union[
            List[Union[date, int]],
            List[Union[date, str]],
            List[Union[Decimal, int]],
            List[Union[int, memoryview]],
            List[Union[int, str]],
            List[float],
        ],
    ]: ...
    def get_group_by_cols(self) -> List[Col]: ...

class Case(Expression):
    template: str = ...
    case_joiner: str = ...
    cases: Any = ...
    default: Any = ...
    extra: Any = ...
    def __init__(
        self,
        *cases: Any,
        default: Optional[Any] = ...,
        output_field: Optional[Any] = ...,
        **extra: Any
    ) -> None: ...
    def get_source_expressions(self) -> List[Expression]: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[Any]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Case: ...
    def copy(self) -> Case: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        case_joiner: None = ...,
        **extra_context: Any
    ) -> Tuple[
        str,
        Union[
            List[Union[date, int]],
            List[Union[date, str]],
            List[Union[Decimal, int]],
            List[Union[int, memoryview]],
            List[Union[int, str]],
            List[float],
        ],
    ]: ...

class Subquery(Expression):
    template: str = ...
    queryset: django.db.models.query.QuerySet = ...
    extra: Dict[Any, Any] = ...
    def __init__(
        self,
        queryset: QuerySet,
        output_field: Optional[Field] = ...,
        **extra: Any
    ) -> None: ...
    def copy(self) -> Subquery: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[Any]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Subquery: ...
    def get_source_expressions(self) -> List[Col]: ...
    def relabeled_clone(self, change_map: OrderedDict) -> Subquery: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        **extra_context: Any
    ) -> Tuple[str, Tuple]: ...

class Exists(Subquery):
    extra: Dict[Any, Any]
    template: str = ...
    output_field: Any = ...
    negated: bool = ...
    def __init__(
        self, *args: Any, negated: bool = ..., **kwargs: Any
    ) -> None: ...
    def __invert__(self) -> Exists: ...
    queryset: django.db.models.query.QuerySet = ...
    def resolve_expression(
        self, query: Query = ..., *args: Any, **kwargs: Any
    ) -> Exists: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: None = ...,
        **extra_context: Any
    ) -> Tuple[str, Tuple]: ...
    def as_oracle(
        self,
        compiler: Any,
        connection: Any,
        template: Optional[Any] = ...,
        **extra_context: Any
    ): ...

class OrderBy(BaseExpression):
    template: str = ...
    nulls_first: bool = ...
    nulls_last: bool = ...
    descending: bool = ...
    expression: django.db.models.expressions.Col = ...
    def __init__(
        self,
        expression: Combinable,
        descending: bool = ...,
        nulls_first: bool = ...,
        nulls_last: bool = ...,
    ) -> None: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def get_source_expressions(self) -> List[Combinable]: ...
    def as_sql(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        template: Optional[str] = ...,
        **extra_context: Any
    ) -> Tuple[str, Union[List[Union[int, str]], Tuple]]: ...
    def as_sqlite(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, Union[List[Union[int, str]], Tuple]]: ...
    def as_mysql(self, compiler: Any, connection: Any): ...
    def get_group_by_cols(self): ...
    def reverse_ordering(self) -> OrderBy: ...
    def asc(self) -> None: ...
    def desc(self) -> None: ...

class Window(Expression):
    template: str = ...
    contains_aggregate: bool = ...
    contains_over_clause: bool = ...
    filterable: bool = ...
    partition_by: None = ...
    order_by: None = ...
    frame: None = ...
    source_expression: django.db.models.aggregates.Sum = ...
    def __init__(
        self,
        expression: Aggregate,
        partition_by: Optional[str] = ...,
        order_by: Optional[Union[OrderBy, str]] = ...,
        frame: None = ...,
        output_field: None = ...,
    ) -> None: ...
    def get_source_expressions(self): ...
    def set_source_expressions(
        self, exprs: List[Optional[DenseRank]]
    ) -> None: ...
    def as_sql(
        self,
        compiler: Any,
        connection: Any,
        function: Optional[Any] = ...,
        template: Optional[Any] = ...,
    ): ...
    def get_group_by_cols(self) -> List[Any]: ...

class WindowFrame(Expression):
    template: str = ...
    start: None = ...
    end: None = ...
    def __init__(self, start: int = ..., end: Optional[int] = ...) -> None: ...
    def set_source_expressions(self, exprs: Any) -> None: ...
    def get_source_expressions(self): ...
    def as_sql(self, compiler: Any, connection: Any): ...
    def get_group_by_cols(self) -> List[Any]: ...
    def window_frame_start_end(
        self, connection: Any, start: Any, end: Any
    ) -> None: ...

class RowRange(WindowFrame):
    end: None
    start: int
    frame_type: str = ...
    def window_frame_start_end(self, connection: Any, start: Any, end: Any): ...

class ValueRange(WindowFrame):
    end: int
    start: None
    frame_type: str = ...
    def window_frame_start_end(self, connection: Any, start: Any, end: Any): ...
