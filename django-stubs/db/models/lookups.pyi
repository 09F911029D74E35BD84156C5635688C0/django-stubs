# Stubs for django.db.models.lookups (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from django.db.models.expressions import Func
from django.db.models.query_utils import RegisterLookupMixin
from typing import Any, Optional

from collections import OrderedDict
from datetime import datetime
from django.db.backends.sqlite3.base import DatabaseWrapper
from django.db.models.expressions import Col, CombinedExpression, Expression, Ref
from django.db.models.fields.related_lookups import MultiColSource
from django.db.models.sql.compiler import SQLCompiler
from django.db.models.sql.query import Query
from django.utils.datastructures import OrderedSet
from django.utils.safestring import SafeText
from typing import Any, Dict, List, Optional, Tuple, Type, Union

class Lookup:
    lookup_name: Any = ...
    prepare_rhs: bool = ...
    can_use_none_as_rhs: bool = ...
    rhs: Any = ...
    bilateral_transforms: Any = ...
    def __init__(self, lhs: Union[MultiColSource, Expression], rhs: object) -> None: ...
    def apply_bilateral_transforms(self, value: Expression) -> Transform: ...
    def batch_process_rhs(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        rhs: Optional[OrderedSet] = ...,
    ) -> Any: ...
    def get_source_expressions(self) -> List[Col]: ...
    lhs: Any = ...
    def set_source_expressions(self, new_exprs: List[Ref]) -> None: ...
    def get_prep_lookup(self) -> Any: ...
    def get_db_prep_lookup(
        self, value: Union[str, int], connection: DatabaseWrapper
    ) -> Union[
        Tuple[str, List[int]], Tuple[str, List[SafeText]], Tuple[str, List[str]]
    ]: ...
    def process_lhs(
        self, compiler: SQLCompiler, connection: DatabaseWrapper, lhs: Optional[Col] = ...
    ) -> Any: ...
    def process_rhs(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def rhs_is_direct_value(self) -> bool: ...
    def relabeled_clone(
        self, relabels: Union[OrderedDict, Dict[str, str], Dict[Union[str, None], str]]
    ) -> Union[IsNull, StartsWith, FieldGetDbPrepValueMixin, IContains]: ...
    def get_group_by_cols(self) -> Union[List[CombinedExpression], List[Col]]: ...
    def as_sql(self, compiler: Any, connection: Any) -> None: ...
    def contains_aggregate(self) -> bool: ...
    def contains_over_clause(self) -> bool: ...
    @property
    def is_summary(self): ...

class Transform(RegisterLookupMixin, Func):
    bilateral: bool = ...
    arity: int = ...
    @property
    def lhs(self) -> Expression: ...
    def get_bilateral_transforms(self) -> List[Type[Transform]]: ...

class BuiltinLookup(Lookup):
    def process_lhs(
        self, compiler: SQLCompiler, connection: DatabaseWrapper, lhs: Optional[Col] = ...
    ) -> Union[
        Tuple[str, List[int]],
        Tuple[str, List[Union[str, int]]],
        Tuple[str, List[Any]],
        Tuple[str, List[str]],
    ]: ...
    def as_sql(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def get_rhs_op(self, connection: DatabaseWrapper, rhs: str) -> str: ...

class FieldGetDbPrepValueMixin:
    get_db_prep_lookup_value_is_iterable: bool = ...
    def get_db_prep_lookup(self, value: object, connection: DatabaseWrapper) -> Any: ...

class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):
    get_db_prep_lookup_value_is_iterable: bool = ...
    def get_prep_lookup(self) -> Any: ...
    def process_rhs(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def resolve_expression_parameter(
        self, compiler: SQLCompiler, connection: DatabaseWrapper, sql: str, param: Any
    ) -> Union[
        Tuple[str, List[None]],
        Tuple[str, List[int]],
        Tuple[str, List[str]],
        Tuple[str, List[Any]],
    ]: ...
    def batch_process_rhs(
        self,
        compiler: SQLCompiler,
        connection: DatabaseWrapper,
        rhs: Optional[OrderedSet] = ...,
    ) -> Any: ...

class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name: str = ...
    def process_rhs(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...

class IExact(BuiltinLookup):
    lookup_name: str = ...
    prepare_rhs: bool = ...
    def process_rhs(
        self, qn: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[str]], Tuple[str, List[Any]]]: ...

class GreaterThan(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name: str = ...

class GreaterThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name: str = ...

class LessThan(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name: str = ...

class LessThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup):
    lookup_name: str = ...

class IntegerFieldFloatRounding:
    rhs: Any = ...
    def get_prep_lookup(self) -> Union[Query, int, CombinedExpression]: ...

class IntegerGreaterThanOrEqual(IntegerFieldFloatRounding, GreaterThanOrEqual): ...
class IntegerLessThan(IntegerFieldFloatRounding, LessThan): ...

class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
    lookup_name: str = ...
    def process_rhs(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def get_rhs_op(self, connection: DatabaseWrapper, rhs: str) -> str: ...
    def as_sql(self, compiler: SQLCompiler, connection: DatabaseWrapper) -> Any: ...
    def split_parameter_list_as_sql(self, compiler: Any, connection: Any): ...

class PatternLookup(BuiltinLookup):
    param_pattern: str = ...
    prepare_rhs: bool = ...
    def get_rhs_op(self, connection: DatabaseWrapper, rhs: str) -> str: ...
    def process_rhs(
        self, qn: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[int]], Tuple[str, List[str]], Tuple[str, List[Any]]]: ...

class Contains(PatternLookup):
    lookup_name: str = ...

class IContains(Contains):
    lookup_name: str = ...

class StartsWith(PatternLookup):
    lookup_name: str = ...
    param_pattern: str = ...

class IStartsWith(StartsWith):
    lookup_name: str = ...

class EndsWith(PatternLookup):
    lookup_name: str = ...
    param_pattern: str = ...

class IEndsWith(EndsWith):
    lookup_name: str = ...

class Range(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
    lookup_name: str = ...
    def get_rhs_op(self, connection: DatabaseWrapper, rhs: Tuple[str, str]) -> str: ...

class IsNull(BuiltinLookup):
    lookup_name: str = ...
    prepare_rhs: bool = ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[Any]]: ...

class Regex(BuiltinLookup):
    lookup_name: str = ...
    prepare_rhs: bool = ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[str]]: ...

class IRegex(Regex):
    lookup_name: str = ...

class YearLookup(Lookup):
    def year_lookup_bounds(self, connection: DatabaseWrapper, year: int) -> List[str]: ...

class YearComparisonLookup(YearLookup):
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Tuple[str, List[str]]: ...
    def get_rhs_op(self, connection: DatabaseWrapper, rhs: str) -> str: ...
    def get_bound(self, start: datetime, finish: datetime) -> None: ...

class YearExact(YearLookup, Exact):
    lookup_name: str = ...
    def as_sql(
        self, compiler: SQLCompiler, connection: DatabaseWrapper
    ) -> Union[Tuple[str, List[str]], Tuple[str, List[Any]]]: ...

class YearGt(YearComparisonLookup):
    lookup_name: str = ...
    def get_bound(self, start: str, finish: str) -> str: ...

class YearGte(YearComparisonLookup):
    lookup_name: str = ...
    def get_bound(self, start: str, finish: str) -> str: ...

class YearLt(YearComparisonLookup):
    lookup_name: str = ...
    def get_bound(self, start: str, finish: str) -> str: ...

class YearLte(YearComparisonLookup):
    lookup_name: str = ...
    def get_bound(self, start: str, finish: str) -> str: ...
