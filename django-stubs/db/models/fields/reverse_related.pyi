# Stubs for django.db.models.fields.reverse_related (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .mixins import FieldCacheMixin
from typing import Any, Optional

from django.db.models.base import Model
from django.db.models.fields import AutoField, Field
from django.db.models.fields.related import ForeignKey, ManyToManyField, RelatedField
from django.db.models.fields.related_lookups import RelatedExact, RelatedIn, RelatedIsNull
from django.db.models.query_utils import FilteredRelation, PathInfo
from django.db.models.sql.where import WhereNode
from typing import Any, Callable, Dict, List, Optional, Tuple, Type, Union
class ForeignObjectRel(FieldCacheMixin):
    auto_created: bool = ...
    concrete: bool = ...
    editable: bool = ...
    is_relation: bool = ...
    null: bool = ...
    field: Any = ...
    model: Any = ...
    related_name: Any = ...
    related_query_name: Any = ...
    limit_choices_to: Any = ...
    parent_link: Any = ...
    on_delete: Any = ...
    symmetrical: bool = ...
    multiple: bool = ...
    def __init__(self, field: RelatedField, to: Any, related_name: Optional[str] = ..., related_query_name: Optional[str] = ..., limit_choices_to: Any = ..., parent_link: bool = ..., on_delete: Optional[Callable] = ...) -> None: ...
    def hidden(self) -> bool: ...
    def name(self) -> str: ...
    @property
    def remote_field(self) -> Union[ManyToManyField, ForeignKey]: ...
    @property
    def target_field(self) -> AutoField: ...
    def related_model(self) -> Type[Model]: ...
    def many_to_many(self) -> bool: ...
    def many_to_one(self) -> bool: ...
    def one_to_many(self) -> bool: ...
    def one_to_one(self) -> bool: ...
    def get_lookup(self, lookup_name: str) -> Type[Union[RelatedIsNull, RelatedExact, RelatedIn]]: ...
    def get_internal_type(self) -> str: ...
    @property
    def db_type(self) -> Callable: ...
    def __repr__(self) -> str: ...
    def get_choices(self, include_blank: bool = ..., blank_choice: List[Tuple[str, str]] = ...) -> List[Tuple[int, str]]: ...
    def is_hidden(self) -> bool: ...
    def get_joining_columns(self) -> Union[Tuple[Tuple[str, str]], Tuple[Tuple[str, str], Tuple[str, str]]]: ...
    def get_extra_restriction(self, where_class: Type[WhereNode], alias: str, related_alias: str) -> Optional[WhereNode]: ...
    field_name: Any = ...
    def set_field_name(self) -> None: ...
    def get_accessor_name(self, model: Optional[Type[Model]] = ...) -> Optional[str]: ...
    def get_path_info(self, filtered_relation: Optional[FilteredRelation] = ...) -> List[PathInfo]: ...
    def get_cache_name(self) -> str: ...

class ManyToOneRel(ForeignObjectRel):
    field_name: Any = ...
    def __init__(self, field: ForeignKey, to: Any, field_name: Optional[str], related_name: Optional[str] = ..., related_query_name: Optional[str] = ..., limit_choices_to: Any = ..., parent_link: bool = ..., on_delete: Callable = ...) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def get_related_field(self): ...
    def set_field_name(self) -> None: ...

class OneToOneRel(ManyToOneRel):
    multiple: bool = ...
    def __init__(self, field: Any, to: Any, field_name: Any, related_name: Optional[Any] = ..., related_query_name: Optional[Any] = ..., limit_choices_to: Optional[Any] = ..., parent_link: bool = ..., on_delete: Optional[Any] = ...) -> None: ...

class ManyToManyRel(ForeignObjectRel):
    through: Any = ...
    through_fields: Any = ...
    symmetrical: Any = ...
    db_constraint: Any = ...
    def __init__(self, field: RelatedField, to: Any, related_name: Optional[str] = ..., related_query_name: Optional[str] = ..., limit_choices_to: Optional[Callable] = ..., symmetrical: bool = ..., through: Optional[Union[str, Type[Model]]] = ..., through_fields: Optional[Tuple[str, str]] = ..., db_constraint: bool = ...) -> None: ...
    def get_related_field(self) -> Field: ...
