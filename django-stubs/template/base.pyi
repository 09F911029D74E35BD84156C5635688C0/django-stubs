from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple, Type, Union

from django.contrib.admin.views.main import ChangeList
from django.template.context import Context
from django.template.engine import Engine
from django.template.library import Library
from django.template.loader_tags import BlockNode, ExtendsNode
from django.template.loaders.filesystem import Loader
from django.utils.safestring import SafeText

from .exceptions import TemplateSyntaxError

FILTER_SEPARATOR: str
FILTER_ARGUMENT_SEPARATOR: str
VARIABLE_ATTRIBUTE_SEPARATOR: str
BLOCK_TAG_START: str
BLOCK_TAG_END: str
VARIABLE_TAG_START: str
VARIABLE_TAG_END: str
COMMENT_TAG_START: str
COMMENT_TAG_END: str
TRANSLATOR_COMMENT_MARK: str
SINGLE_BRACE_START: str
SINGLE_BRACE_END: str
UNKNOWN_SOURCE: str
tag_re: Any
logger: Any

class TokenType(Enum):
    TEXT: int = ...
    VAR: int = ...
    BLOCK: int = ...
    COMMENT: int = ...

class VariableDoesNotExist(Exception):
    msg: str = ...
    params: Union[
        Tuple[
            str,
            Union[
                int,
                django.urls.resolvers.URLResolver,
                Dict[Any, Any],
                django.contrib.admin.views.main.ChangeList,
                Dict[str, str],
                List[str],
                None,
                django.template.context.Context,
                Dict[str, int],
                Any,
                Dict[str, bool],
                Dict[str, Union[str, bool]],
                str,
            ],
        ],
        Tuple[Dict[str, str]],
    ] = ...
    def __init__(
        self,
        msg: str,
        params: Tuple[str, Optional[Union[Context, ChangeList]]] = ...,
    ) -> None: ...

class Origin:
    name: str = ...
    template_name: Optional[Union[str, bytes]] = ...
    loader: Optional[
        Union[
            django.template.loaders.base.Loader,
            django.template.backends.dummy.TemplateStrings,
        ]
    ] = ...
    def __init__(
        self, name: str, template_name: str = ..., loader: Loader = ...
    ) -> None: ...
    def __eq__(self, other: Origin) -> bool: ...
    @property
    def loader_name(self): ...

class Template:
    name: Optional[str] = ...
    origin: django.template.base.Origin = ...
    engine: django.template.engine.Engine = ...
    source: str = ...
    nodelist: django.template.base.NodeList = ...
    def __init__(
        self,
        template_string: str,
        origin: Origin = ...,
        name: str = ...,
        engine: Engine = ...,
    ) -> None: ...
    def __iter__(self) -> None: ...
    def render(self, context: Context) -> Any: ...
    def compile_nodelist(self) -> NodeList: ...
    def get_exception_info(
        self, exception: Exception, token: Token
    ) -> Dict[str, Union[str, List[Tuple[int, SafeText]], int]]: ...

def linebreak_iter(template_source: Any) -> None: ...

class Token:
    contents: str
    token_type: django.template.base.TokenType
    lineno: Optional[int] = ...
    position: Optional[Tuple[int, int]] = ...
    def __init__(
        self,
        token_type: TokenType,
        contents: str,
        position: Optional[Tuple[int, int]] = ...,
        lineno: int = ...,
    ) -> None: ...
    def split_contents(self) -> List[str]: ...

class Lexer:
    template_string: str = ...
    verbatim: Union[str, bool] = ...
    def __init__(self, template_string: str) -> None: ...
    def tokenize(self) -> List[Token]: ...
    def create_token(
        self,
        token_string: str,
        position: Optional[Tuple[int, int]],
        lineno: int,
        in_tag: bool,
    ) -> Token: ...

class DebugLexer(Lexer):
    template_string: str
    verbatim: Union[str, bool]
    def tokenize(self) -> List[Token]: ...

class Parser:
    tokens: Union[str, List[django.template.base.Token]] = ...
    tags: Dict[str, Callable] = ...
    filters: Dict[str, Callable] = ...
    command_stack: List[Tuple[str, django.template.base.Token]] = ...
    libraries: Dict[str, django.template.library.Library] = ...
    origin: Optional[django.template.base.Origin] = ...
    def __init__(
        self,
        tokens: List[Token],
        libraries: Dict[str, Library] = ...,
        builtins: List[Library] = ...,
        origin: Origin = ...,
    ) -> None: ...
    def parse(self, parse_until: Optional[Tuple[str]] = ...) -> NodeList: ...
    def skip_past(self, endtag: Any): ...
    def extend_nodelist(
        self, nodelist: NodeList, node: Node, token: Token
    ) -> None: ...
    def error(self, token: Any, e: Any): ...
    def invalid_block_tag(
        self, token: Any, command: Any, parse_until: Optional[Any] = ...
    ) -> None: ...
    def unclosed_block_tag(self, parse_until: Any) -> None: ...
    def next_token(self) -> Token: ...
    def prepend_token(self, token: Token) -> None: ...
    def delete_first_token(self) -> None: ...
    def add_library(self, lib: Library) -> None: ...
    def compile_filter(self, token: str) -> FilterExpression: ...
    def find_filter(self, filter_name: str) -> Callable: ...

constant_string: Any
filter_raw_string: Any
filter_re: Any

class FilterExpression:
    token: str = ...
    filters: Union[
        List[
            Tuple[Callable, List[Tuple[bool, django.utils.safestring.SafeText]]]
        ],
        List[Tuple[Callable, List[Tuple[bool, django.template.base.Variable]]]],
    ] = ...
    var: Union[
        django.utils.safestring.SafeText, django.template.base.Variable
    ] = ...
    def __init__(self, token: str, parser: Parser) -> None: ...
    def resolve(self, context: Context, ignore_failures: bool = ...) -> Any: ...
    def args_check(
        name: str,
        func: Callable,
        provided: Union[
            List[Tuple[bool, Variable]], List[Tuple[bool, SafeText]]
        ],
    ) -> bool: ...
    args_check: Any = ...

class Variable:
    var: Union[str, Dict[Any, Any]] = ...
    literal: Optional[Union[float, django.utils.safestring.SafeText]] = ...
    lookups: Optional[Tuple[str]] = ...
    translate: bool = ...
    message_context: Optional[str] = ...
    def __init__(self, var: str) -> None: ...
    def resolve(self, context: Union[Context, Dict[Any, Any]]) -> Any: ...

class Node:
    must_be_first: bool = ...
    child_nodelists: Any = ...
    token: Any = ...
    def render(self, context: Any) -> None: ...
    def render_annotated(self, context: Context) -> str: ...
    def __iter__(self) -> None: ...
    def get_nodes_by_type(
        self, nodetype: Type[Union[ExtendsNode, BlockNode]]
    ) -> List[BlockNode]: ...

class NodeList(list):
    contains_nontext: bool = ...
    def render(self, context: Context) -> SafeText: ...
    def get_nodes_by_type(
        self, nodetype: Type[Union[ExtendsNode, BlockNode]]
    ) -> List[BlockNode]: ...

class TextNode(Node):
    origin: django.template.base.Origin
    token: django.template.base.Token
    s: str = ...
    def __init__(self, s: str) -> None: ...
    def render(self, context: Context) -> str: ...

def render_value_in_context(value: Any, context: Context) -> SafeText: ...

class VariableNode(Node):
    origin: django.template.base.Origin
    token: django.template.base.Token
    filter_expression: django.template.base.FilterExpression = ...
    def __init__(self, filter_expression: FilterExpression) -> None: ...
    def render(self, context: Context) -> SafeText: ...

kwarg_re: Any

def token_kwargs(
    bits: List[str], parser: Parser, support_legacy: bool = ...
) -> Dict[str, FilterExpression]: ...
