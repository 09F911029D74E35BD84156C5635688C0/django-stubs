# Stubs for django.template.base (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .exceptions import TemplateSyntaxError
from enum import Enum
from typing import Any, Optional

from django.template.backends.dummy import TemplateStrings
from django.template.context import Context
from django.template.defaulttags import LoadNode
from django.template.engine import Engine
from django.template.exceptions import TemplateSyntaxError
from django.template.library import Library
from django.template.loader_tags import BlockNode, ExtendsNode
from django.template.loaders.base import Loader
from django.utils.safestring import SafeText
from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Type, Union
FILTER_SEPARATOR: str
FILTER_ARGUMENT_SEPARATOR: str
VARIABLE_ATTRIBUTE_SEPARATOR: str
BLOCK_TAG_START: str
BLOCK_TAG_END: str
VARIABLE_TAG_START: str
VARIABLE_TAG_END: str
COMMENT_TAG_START: str
COMMENT_TAG_END: str
TRANSLATOR_COMMENT_MARK: str
SINGLE_BRACE_START: str
SINGLE_BRACE_END: str
UNKNOWN_SOURCE: str
tag_re: Any
logger: Any

class TokenType(Enum):
    TEXT: int = ...
    VAR: int = ...
    BLOCK: int = ...
    COMMENT: int = ...

class VariableDoesNotExist(Exception):
    msg: Any = ...
    params: Any = ...
    def __init__(self, msg: str, params: Any = ...) -> None: ...
    def __str__(self) -> str: ...

class Origin:
    name: Any = ...
    template_name: Any = ...
    loader: Any = ...
    def __init__(self, name: str, template_name: Optional[str] = ..., loader: Optional[Union[Loader, TemplateStrings]] = ...) -> None: ...
    def __str__(self): ...
    def __eq__(self, other: Origin) -> bool: ...
    @property
    def loader_name(self) -> Optional[str]: ...

class Template:
    name: Any = ...
    origin: Any = ...
    engine: Any = ...
    source: Any = ...
    nodelist: Any = ...
    def __init__(self, template_string: str, origin: Optional[Origin] = ..., name: Optional[str] = ..., engine: Optional[Engine] = ...) -> None: ...
    def __iter__(self) -> None: ...
    def _render(self, context: Any): ...
    def render(self, context: Context): ...
    def compile_nodelist(self) -> NodeList: ...
    def get_exception_info(self, exception: Exception, token: Token) -> Dict[str, Union[str, List[Tuple[int, SafeText]], int]]: ...

def linebreak_iter(template_source: str) -> Iterator[int]: ...

class Token:
    lineno: Any = ...
    position: Any = ...
    def __init__(self, token_type: TokenType, contents: str, position: Optional[Tuple[int, int]] = ..., lineno: Optional[int] = ...) -> None: ...
    def __str__(self): ...
    def split_contents(self) -> List[str]: ...

class Lexer:
    template_string: Any = ...
    verbatim: bool = ...
    def __init__(self, template_string: str) -> None: ...
    def tokenize(self) -> List[Token]: ...
    def create_token(self, token_string: str, position: Optional[Tuple[int, int]], lineno: int, in_tag: bool) -> Token: ...

class DebugLexer(Lexer):
    def tokenize(self) -> List[Token]: ...

class Parser:
    tokens: Any = ...
    tags: Any = ...
    filters: Any = ...
    command_stack: Any = ...
    libraries: Any = ...
    origin: Any = ...
    def __init__(self, tokens: Union[str, List[Token]], libraries: Optional[Dict[str, Library]] = ..., builtins: List[Library] = ..., origin: Optional[Origin] = ...) -> None: ...
    def parse(self, parse_until: Optional[Union[Tuple[str, str], Tuple[str], Tuple[str, str, str]]] = ...) -> NodeList: ...
    def skip_past(self, endtag: str) -> None: ...
    def extend_nodelist(self, nodelist: NodeList, node: Node, token: Token) -> None: ...
    def error(self, token: Token, e: Union[str, RuntimeError, TemplateSyntaxError]) -> Union[RuntimeError, TemplateSyntaxError]: ...
    def invalid_block_tag(self, token: Token, command: str, parse_until: Union[Tuple[str], Tuple[str, str]] = ...) -> None: ...
    def unclosed_block_tag(self, parse_until: Union[Tuple[str], Tuple[str, str, str]]) -> None: ...
    def next_token(self) -> Token: ...
    def prepend_token(self, token: Token) -> None: ...
    def delete_first_token(self) -> None: ...
    def add_library(self, lib: Library) -> None: ...
    def compile_filter(self, token: str) -> FilterExpression: ...
    def find_filter(self, filter_name: str) -> Callable: ...

constant_string: Any
filter_raw_string: Any
filter_re: Any

class FilterExpression:
    token: Any = ...
    filters: Any = ...
    var: Any = ...
    def __init__(self, token: str, parser: Parser) -> None: ...
    def resolve(self, context: Union[Dict[str, Dict[str, str]], Context], ignore_failures: bool = ...) -> object: ...
    def args_check(name: str, func: Callable, provided: Union[List[Tuple[bool, SafeText]], List[Tuple[bool, Variable]]]) -> bool: ...
    args_check: Any = ...
    def __str__(self) -> str: ...

class Variable:
    var: Any = ...
    literal: Any = ...
    lookups: Any = ...
    translate: bool = ...
    message_context: Any = ...
    def __init__(self, var: str) -> None: ...
    def resolve(self, context: Any) -> object: ...
    def __repr__(self): ...
    def __str__(self): ...
    def _resolve_lookup(self, context: Any) -> object: ...

class Node:
    must_be_first: bool = ...
    child_nodelists: Any = ...
    token: Any = ...
    def render(self, context: Any) -> None: ...
    def render_annotated(self, context: Context) -> Union[int, str]: ...
    def __iter__(self) -> None: ...
    def get_nodes_by_type(self, nodetype: Type[Node]) -> Union[List[LoadNode], List[VariableNode], List[BlockNode], List[ExtendsNode]]: ...

class NodeList(list):
    contains_nontext: bool = ...
    def render(self, context: Context) -> SafeText: ...
    def get_nodes_by_type(self, nodetype: Type[Node]) -> Union[List[BlockNode], List[VariableNode]]: ...

class TextNode(Node):
    s: Any = ...
    def __init__(self, s: str) -> None: ...
    def __repr__(self) -> str: ...
    def render(self, context: Context) -> str: ...

def render_value_in_context(value: object, context: Context) -> str: ...

class VariableNode(Node):
    filter_expression: Any = ...
    def __init__(self, filter_expression: FilterExpression) -> None: ...
    def __repr__(self) -> str: ...
    def render(self, context: Context) -> str: ...

kwarg_re: Any

def token_kwargs(bits: List[str], parser: Parser, support_legacy: bool = ...) -> Dict[str, FilterExpression]: ...
