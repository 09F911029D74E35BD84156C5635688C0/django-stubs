# Stubs for django.forms.widgets (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

from datetime import date, datetime, time
from django.core.files.uploadedfile import SimpleUploadedFile
from django.db.models.fields.files import FieldFile
from django.forms.renderers import DjangoTemplates
from django.http.request import QueryDict
from django.utils.datastructures import MultiValueDict
from django.utils.safestring import SafeText
from itertools import chain
from typing import Any, Callable, Dict, Iterator, List, Optional, Set, Tuple, Type, Union

class MediaOrderConflictWarning(RuntimeWarning): ...

class Media:
    _css: Any = ...
    _js: Any = ...
    def __init__(
        self,
        media: Optional[Type[object]] = ...,
        css: Optional[
            Union[Dict[str, Tuple[str, str]], Dict[str, List[str]], Dict[str, Tuple[str]]]
        ] = ...,
        js: Any = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self): ...
    def render(self) -> SafeText: ...
    def render_js(self) -> List[SafeText]: ...
    def render_css(self) -> chain: ...
    def absolute_path(self, path: str) -> str: ...
    def __getitem__(self, name: str) -> Media: ...
    @staticmethod
    def merge(
        list_1: Union[List[int], List[str], Tuple[str]], list_2: Any
    ) -> Union[List[int], List[str]]: ...
    def __add__(self, other: Media) -> Media: ...

class MediaDefiningClass(type):
    def __new__(
        mcs: Type[MediaDefiningClass], name: str, bases: Tuple, attrs: Any
    ) -> Type[Any]: ...

class Widget:
    needs_multipart_form: bool = ...
    is_localized: bool = ...
    is_required: bool = ...
    supports_microseconds: bool = ...
    attrs: Any = ...
    def __init__(self, attrs: Any = ...) -> None: ...
    def __deepcopy__(self, memo: Dict[int, Any]) -> Widget: ...
    @property
    def is_hidden(self): ...
    def subwidgets(self, name: Any, value: Any, attrs: Optional[Any] = ...) -> None: ...
    def format_value(self, value: Any) -> Optional[str]: ...
    def get_context(
        self,
        name: str,
        value: Any,
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ],
    ) -> Dict[str, Dict[str, Any]]: ...
    def render(
        self,
        name: Any,
        value: Any,
        attrs: Optional[Any] = ...,
        renderer: Optional[Any] = ...,
    ): ...
    def _render(
        self,
        template_name: str,
        context: Dict[str, Any],
        renderer: Optional[DjangoTemplates] = ...,
    ) -> SafeText: ...
    def build_attrs(
        self,
        base_attrs: Dict[str, Union[float, str]],
        extra_attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ] = ...,
    ) -> Dict[str, Union[float, str]]: ...
    def value_from_datadict(self, data: Any, files: Any, name: Any): ...
    def value_omitted_from_data(self, data: Any, files: Any, name: Any): ...
    def id_for_label(self, id_: Any): ...
    def use_required_attribute(self, initial: Any): ...

class Input(Widget):
    input_type: Any = ...
    template_name: str = ...
    def __init__(
        self, attrs: Optional[Union[Dict[str, int], Dict[str, str], Dict[str, bool]]] = ...
    ) -> None: ...
    def get_context(
        self,
        name: str,
        value: Any,
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ],
    ) -> Dict[str, Dict[str, Any]]: ...

class TextInput(Input):
    input_type: str = ...
    template_name: str = ...

class NumberInput(Input):
    input_type: str = ...
    template_name: str = ...

class EmailInput(Input):
    input_type: str = ...
    template_name: str = ...

class URLInput(Input):
    input_type: str = ...
    template_name: str = ...

class PasswordInput(Input):
    input_type: str = ...
    template_name: str = ...
    render_value: Any = ...
    def __init__(
        self, attrs: Optional[Dict[str, bool]] = ..., render_value: bool = ...
    ) -> None: ...
    def get_context(
        self,
        name: str,
        value: Optional[str],
        attrs: Optional[Union[Dict[str, Union[str, bool]], Dict[str, bool]]],
    ) -> Dict[str, Dict[str, Any]]: ...

class HiddenInput(Input):
    input_type: str = ...
    template_name: str = ...

class MultipleHiddenInput(HiddenInput):
    template_name: str = ...
    def get_context(
        self, name: str, value: List[str], attrs: Optional[Dict[str, str]]
    ) -> Dict[str, Dict[str, Any]]: ...
    def value_from_datadict(
        self, data: MultiValueDict, files: Dict[Any, Any], name: str
    ) -> List[str]: ...
    def format_value(
        self, value: Union[List[int], List[str]]
    ) -> Union[List[int], List[str]]: ...

class FileInput(Input):
    input_type: str = ...
    needs_multipart_form: bool = ...
    template_name: str = ...
    def format_value(self, value: None) -> None: ...
    def value_from_datadict(
        self,
        data: Union[Dict[str, str], Dict[str, bool], QueryDict],
        files: Dict[str, SimpleUploadedFile],
        name: str,
    ) -> Optional[SimpleUploadedFile]: ...
    def value_omitted_from_data(
        self,
        data: Dict[Any, Any],
        files: Dict[str, Union[SimpleUploadedFile, str]],
        name: str,
    ) -> bool: ...

class ClearableFileInput(FileInput):
    clear_checkbox_label: Any = ...
    initial_text: Any = ...
    input_text: Any = ...
    template_name: str = ...
    def clear_checkbox_name(self, name: str) -> str: ...
    def clear_checkbox_id(self, name: str) -> str: ...
    def is_initial(self, value: object) -> bool: ...
    def format_value(
        self, value: Optional[Union[str, FieldFile]]
    ) -> Optional[FieldFile]: ...
    def get_context(self, name: Any, value: Any, attrs: Any): ...
    def value_from_datadict(
        self,
        data: Union[Dict[str, bool], Dict[str, None], Dict[str, str], QueryDict],
        files: Dict[str, Union[SimpleUploadedFile, str]],
        name: str,
    ) -> Optional[Union[str, SimpleUploadedFile]]: ...
    def use_required_attribute(self, initial: Optional[FieldFile]) -> bool: ...
    def value_omitted_from_data(
        self, data: Dict[str, str], files: Dict[Any, Any], name: str
    ) -> bool: ...

class Textarea(Widget):
    template_name: str = ...
    def __init__(
        self, attrs: Optional[Union[Dict[str, int], Dict[str, str]]] = ...
    ) -> None: ...

class DateTimeBaseInput(TextInput):
    format_key: str = ...
    supports_microseconds: bool = ...
    format: Any = ...
    def __init__(
        self, attrs: Optional[Dict[str, str]] = ..., format: Optional[str] = ...
    ) -> None: ...
    def format_value(self, value: Optional[Union[time, str, date]]) -> Optional[str]: ...

class DateInput(DateTimeBaseInput):
    format_key: str = ...
    template_name: str = ...

class DateTimeInput(DateTimeBaseInput):
    format_key: str = ...
    template_name: str = ...

class TimeInput(DateTimeBaseInput):
    format_key: str = ...
    template_name: str = ...

class CheckboxInput(Input):
    input_type: str = ...
    template_name: str = ...
    check_test: Any = ...
    def __init__(
        self, attrs: Optional[Dict[str, str]] = ..., check_test: Optional[Callable] = ...
    ) -> None: ...
    def format_value(self, value: Optional[Union[str, int]]) -> Optional[str]: ...
    def get_context(
        self,
        name: str,
        value: Optional[Union[int, str]],
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ],
    ) -> Dict[str, Dict[str, Any]]: ...
    def value_from_datadict(
        self,
        data: Any,
        files: Union[MultiValueDict, Dict[str, SimpleUploadedFile]],
        name: str,
    ) -> bool: ...
    def value_omitted_from_data(
        self,
        data: Union[
            Dict[str, Union[str, List[int]]],
            Dict[str, str],
            Dict[str, Union[int, str, None, datetime]],
            QueryDict,
        ],
        files: MultiValueDict,
        name: str,
    ) -> bool: ...

class ChoiceWidget(Widget):
    allow_multiple_selected: bool = ...
    input_type: Any = ...
    template_name: Any = ...
    option_template_name: Any = ...
    add_id_index: bool = ...
    checked_attribute: Any = ...
    option_inherits_attrs: bool = ...
    choices: Any = ...
    def __init__(
        self,
        attrs: Optional[Union[Dict[str, Union[bool, str]], Dict[str, str]]] = ...,
        choices: Any = ...,
    ) -> None: ...
    def __deepcopy__(self, memo: Dict[int, Any]) -> ChoiceWidget: ...
    def subwidgets(
        self,
        name: str,
        value: Optional[List[str]],
        attrs: Dict[str, Union[bool, str]] = ...,
    ) -> None: ...
    def options(
        self, name: str, value: List[str], attrs: Dict[str, Union[bool, str]] = ...
    ) -> None: ...
    def optgroups(
        self,
        name: str,
        value: List[str],
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ] = ...,
    ) -> Any: ...
    def create_option(
        self,
        name: str,
        value: Union[str, time, int],
        label: Union[str, int],
        selected: Union[bool, Set[str]],
        index: int,
        subindex: Optional[int] = ...,
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ] = ...,
    ) -> Dict[str, Any]: ...
    def get_context(
        self,
        name: str,
        value: Any,
        attrs: Optional[
            Union[Dict[str, Union[bool, str]], Dict[str, bool], Dict[str, str]]
        ],
    ) -> Dict[str, Dict[str, Any]]: ...
    def id_for_label(self, id_: str, index: str = ...) -> str: ...
    def value_from_datadict(
        self, data: dict, files: MultiValueDict, name: str
    ) -> Optional[Union[str, List[str], int]]: ...
    def format_value(self, value: Any) -> List[str]: ...

class Select(ChoiceWidget):
    input_type: str = ...
    template_name: str = ...
    option_template_name: str = ...
    add_id_index: bool = ...
    checked_attribute: Any = ...
    option_inherits_attrs: bool = ...
    def get_context(
        self,
        name: str,
        value: Any,
        attrs: Optional[
            Union[Dict[str, Union[str, bool]], Dict[str, bool], Dict[str, str]]
        ],
    ) -> Dict[str, Dict[str, Any]]: ...
    @staticmethod
    def _choice_has_empty_value(
        choice: Union[Tuple[None, str], Tuple[str, str]]
    ) -> bool: ...
    def use_required_attribute(self, initial: Any) -> bool: ...

class NullBooleanSelect(Select):
    def __init__(self, attrs: None = ...) -> None: ...
    def format_value(self, value: Optional[str]) -> str: ...
    def value_from_datadict(
        self, data: Dict[str, Union[str, bool]], files: Dict[Any, Any], name: str
    ) -> Optional[bool]: ...

class SelectMultiple(Select):
    allow_multiple_selected: bool = ...
    def value_from_datadict(
        self, data: Any, files: MultiValueDict, name: str
    ) -> Optional[Union[List[int], str, List[str]]]: ...
    def value_omitted_from_data(
        self, data: Dict[Any, Any], files: Dict[Any, Any], name: str
    ) -> bool: ...

class RadioSelect(ChoiceWidget):
    input_type: str = ...
    template_name: str = ...
    option_template_name: str = ...

class CheckboxSelectMultiple(ChoiceWidget):
    allow_multiple_selected: bool = ...
    input_type: str = ...
    template_name: str = ...
    option_template_name: str = ...
    def use_required_attribute(self, initial: None) -> bool: ...
    def value_omitted_from_data(
        self, data: Dict[Any, Any], files: Dict[Any, Any], name: str
    ) -> bool: ...
    def id_for_label(self, id_: str, index: Optional[str] = ...) -> str: ...

class MultiWidget(Widget):
    template_name: str = ...
    widgets: Any = ...
    def __init__(self, widgets: Any, attrs: Optional[Dict[str, str]] = ...) -> None: ...
    @property
    def is_hidden(self) -> bool: ...
    def get_context(
        self,
        name: str,
        value: Optional[Union[str, datetime, List[str]]],
        attrs: Optional[Union[Dict[str, Union[str, bool]], Dict[str, str]]],
    ) -> Dict[str, Dict[str, Any]]: ...
    def id_for_label(self, id_: str) -> str: ...
    def value_from_datadict(
        self,
        data: Union[Dict[str, str], Dict[str, Union[str, List[str]]], QueryDict],
        files: MultiValueDict,
        name: str,
    ) -> Union[List[None], List[str]]: ...
    def value_omitted_from_data(
        self, data: Union[Dict[str, str], QueryDict], files: MultiValueDict, name: str
    ) -> bool: ...
    def decompress(self, value: Any) -> None: ...
    def _get_media(self) -> Media: ...
    media: Any = ...
    def __deepcopy__(self, memo: Dict[int, Any]) -> MultiWidget: ...
    @property
    def needs_multipart_form(self) -> bool: ...

class SplitDateTimeWidget(MultiWidget):
    supports_microseconds: bool = ...
    template_name: str = ...
    def __init__(
        self,
        attrs: Optional[Dict[str, str]] = ...,
        date_format: None = ...,
        time_format: None = ...,
        date_attrs: Optional[Dict[str, str]] = ...,
        time_attrs: Optional[Dict[str, str]] = ...,
    ) -> None: ...
    def decompress(
        self, value: Optional[datetime]
    ) -> Union[List[Union[date, time]], List[None]]: ...

class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    template_name: str = ...
    def __init__(
        self,
        attrs: None = ...,
        date_format: None = ...,
        time_format: None = ...,
        date_attrs: None = ...,
        time_attrs: None = ...,
    ) -> None: ...

class SelectDateWidget(Widget):
    none_value: Any = ...
    month_field: str = ...
    day_field: str = ...
    year_field: str = ...
    template_name: str = ...
    input_type: str = ...
    select_widget: Any = ...
    date_re: Any = ...
    attrs: Any = ...
    years: Any = ...
    months: Any = ...
    year_none_value: Any = ...
    month_none_value: Any = ...
    day_none_value: Any = ...
    def __init__(
        self,
        attrs: None = ...,
        years: Optional[Union[range, Tuple[str]]] = ...,
        months: None = ...,
        empty_label: Optional[Tuple[str, str, str]] = ...,
    ) -> None: ...
    def get_context(self, name: Any, value: Any, attrs: Any): ...
    def format_value(
        self, value: Optional[Union[str, date]]
    ) -> Dict[str, Optional[Union[str, int]]]: ...
    @staticmethod
    def _parse_date_fmt() -> Iterator[str]: ...
    def id_for_label(self, id_: Any): ...
    def value_from_datadict(
        self, data: Dict[str, str], files: Dict[Any, Any], name: str
    ) -> Optional[str]: ...
    def value_omitted_from_data(
        self, data: Dict[str, str], files: Dict[Any, Any], name: str
    ) -> bool: ...
